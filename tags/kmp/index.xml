<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>KMP on 배하람 블로그</title>
    <link>https://baeharam.github.io/tags/kmp/</link>
    <description>Recent content in KMP on 배하람 블로그</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <managingEditor>gkfka6484@gmail.com (배하람)</managingEditor>
    <webMaster>gkfka6484@gmail.com (배하람)</webMaster>
    <lastBuildDate>Mon, 08 Jul 2019 17:38:54 +0900</lastBuildDate>
    
	<atom:link href="https://baeharam.github.io/tags/kmp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[알고리즘] KMP 알고리즘</title>
      <link>https://baeharam.github.io/posts/kmp/</link>
      <pubDate>Mon, 08 Jul 2019 17:38:54 +0900</pubDate>
      <author>gkfka6484@gmail.com (배하람)</author>
      <guid>https://baeharam.github.io/posts/kmp/</guid>
      <description>다른 분야도 약하긴 하지만, 문자열이 상당히 약하기 때문에 전에 대충 공부했던 KMP를 다시 꺼내들어서 공부했다. 상당히 어려운 알고리즘이었고 이해하는데 꽤 오랜 시간이 걸렸다. 까먹으면 안되겠지만 혹시 몰라서 까먹을 나중을 위해서 공들여 정리하고자 한다.
개요 KMP 알고리즘은 어떤 문자열 $H$와 $S$가 주어졌고 $H$가 $S$보다 긴 경우에, $H$ 안에 $S$가 포함되어 있는지를 탐색하는 알고리즘이다. 자, 생각을 해보자. 예를 들어 단순 브루트 포스로 $S$를 탐색한다면 상당히 오랜 시간이 걸릴 수밖에 없다.
예를 들어, ABAABAA라는 문자열 $H$에서 부분문자열 ABAC를 찾기 위해선 아래와 같이 찾아야 한다.</description>
    </item>
    
  </channel>
</rss>